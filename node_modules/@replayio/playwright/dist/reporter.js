'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var logger = require('./_bundled/@replay-cli/shared/logger.js');
var mixpanelClient = require('./_bundled/@replay-cli/shared/mixpanelClient.js');
var waitForExitTasks = require('./_bundled/@replay-cli/shared/process/waitForExitTasks.js');
var getRuntimePath = require('./_bundled/@replay-cli/shared/runtime/getRuntimePath.js');
var initializeSession = require('./_bundled/@replay-cli/shared/session/initializeSession.js');
var theme = require('./_bundled/@replay-cli/shared/theme.js');
require('node-fetch');
var getAccessToken = require('./_bundled/@replayio/test-utils/getAccessToken.js');
require('os');
var path = require('path');
var fs = require('fs');
require('node:os');
var reporter = require('./_bundled/@replayio/test-utils/reporter.js');
var terminal = require('./_bundled/@replayio/test-utils/terminal.js');
require('sha-1');
var _package = require('./package.json.js');
var constants = require('./constants.js');
var assert = require('assert');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var assert__default = /*#__PURE__*/_interopDefault(assert);

function extractErrorMessage(error) {
  const message = terminal.removeAnsiCodes(error.message);
  if (message) {
    const errorMessageLines = message.split("\n");
    let stackStart = errorMessageLines.findIndex((l) => l.startsWith("Call log:"));
    stackStart = stackStart == null || stackStart === -1 ? 10 : Math.min(stackStart, 10);
    return errorMessageLines.slice(0, stackStart).join("\n");
  } else if (error.value != null) {
    return error.value;
  }
  return "Unknown error";
}
function mapFixtureStepCategory(step) {
  if (step.apiName.startsWith("expect")) {
    return "assertion";
  }
  return "command";
}
class ReplayPlaywrightReporter {
  reporter;
  captureTestFile;
  config;
  _executedProjects = {};
  constructor(config) {
    initializeSession.initializeSession({
      accessToken: getAccessToken.getAccessToken(config),
      packageName: _package.name,
      packageVersion: _package.version
    });
    if (!config || typeof config !== "object") {
      mixpanelClient.trackEvent("error.invalid-reporter-config", { config });
      throw new Error(
        `Expected an object for @replayio/playwright/reporter configuration but received: ${config}`
      );
    }
    this.config = config;
    this.reporter = new reporter.default(
      {
        name: "playwright",
        version: void 0,
        plugin: _package.version
      },
      "2.2.0",
      // Schema version
      { ...this.config, metadataKey: "PLAYWRIGHT_REPLAY_METADATA" }
    );
    this.captureTestFile = "captureTestFile" in config ? !!config.captureTestFile : ["1", "true"].includes(
      process.env.PLAYWRIGHT_REPLAY_CAPTURE_TEST_FILE?.toLowerCase() || "true"
    );
  }
  // Playwright already provides a unique test id:
  // https://github.com/microsoft/playwright/blob/6fb214de2378a9d874b46df6ea99d04da5765cba/packages/playwright/src/common/suiteUtils.ts#L56-L57
  // this is different because it includes `repeatEachIndex` and `attempt`
  // TODO(PRO-667): this could be simplified to `${test.testId}-${test.repeatEachIndex}-${test.attempt}`
  // before doing that all recipients of `TestExecutionIdData` should be rechecked to see if such a change would be safe
  _getTestExecutionId(test) {
    return [
      test.filePath,
      test.projectName ?? "",
      test.repeatEachIndex,
      test.attempt,
      ...test.source.scope,
      test.source.title
    ].join("-");
  }
  getSource(test) {
    return {
      title: test.title,
      scope: test.titlePath().slice(3, -1)
    };
  }
  onBegin({ version }) {
    this.reporter.setTestRunnerVersion(version);
    this.reporter.onTestSuiteBegin();
  }
  _registerExecutedProject(test) {
    const project = test.parent.project();
    if (project) {
      let projectMetadata = this._executedProjects[project.name];
      if (!projectMetadata) {
        projectMetadata = this._executedProjects[project.name] = {
          usesReplayBrowser: project.use.launchOptions?.executablePath === getRuntimePath.getRuntimePath()
        };
      }
      return projectMetadata;
    }
    return null;
  }
  onTestBegin(test, testResult) {
    const projectMetadata = this._registerExecutedProject(test);
    if (!projectMetadata?.usesReplayBrowser) return;
    this.reporter.onTestBegin();
  }
  _processAttachments(testData, attachments) {
    const indexedSteps = /* @__PURE__ */ new Map();
    const hookMap = {
      afterAll: [],
      afterEach: [],
      beforeAll: [],
      beforeEach: []
    };
    const main = [];
    const stacks = {};
    const filenames = /* @__PURE__ */ new Set([testData.filePath]);
    for (const attachment of attachments) {
      if (attachment.contentType !== constants.REPLAY_CONTENT_TYPE || !attachment.body) {
        continue;
      }
      switch (attachment.name) {
        case "replay:test:start": {
          testData.executionId = JSON.parse(attachment.body.toString()).executionId;
          break;
        }
        case "replay:step:start": {
          const fixtureStep = JSON.parse(attachment.body.toString());
          const step = {
            data: {
              id: fixtureStep.id,
              parentId: null,
              command: {
                name: fixtureStep.apiName,
                arguments: this.parseArguments(fixtureStep.apiName, fixtureStep.params)
              },
              scope: testData.source.scope,
              error: null,
              category: mapFixtureStepCategory(fixtureStep)
            }
          };
          indexedSteps.set(fixtureStep.id, step);
          const stack = fixtureStep.frames.map((frame) => ({
            line: frame.line,
            column: frame.column,
            functionName: frame.function,
            file: path__default.default.relative(process.cwd(), frame.file)
          }));
          if (stack) {
            stacks[fixtureStep.id] = stack;
            for (const frame of stack) {
              filenames.add(frame.file);
            }
          }
          if (fixtureStep.hook) {
            hookMap[fixtureStep.hook].push(step);
          } else {
            main.push(step);
          }
          break;
        }
        case "replay:step:end": {
          const fixtureStep = JSON.parse(attachment.body.toString());
          if (!fixtureStep.error) {
            break;
          }
          const step = indexedSteps.get(fixtureStep.id);
          if (!step) {
            break;
          }
          step.data.error = fixtureStep.error;
          break;
        }
        case "replay:step:error": {
          const fixtureEvent = JSON.parse(attachment.body.toString());
          this.reporter.addError(
            new reporter.ReporterError(fixtureEvent.code, fixtureEvent.message, fixtureEvent.detail),
            {
              ...testData
            }
          );
          break;
        }
      }
    }
    assert__default.default(
      testData.executionId,
      "Expected `executionId` to be set by `replay:test:start` attachment"
    );
    return {
      events: {
        ...hookMap,
        main
      },
      filenames,
      stacks
    };
  }
  onTestEnd(test, result) {
    const status = result.status;
    if (status === "skipped") return;
    const projectMetadata = this._registerExecutedProject(test);
    if (!projectMetadata?.usesReplayBrowser) return;
    const testData = {
      executionId: "",
      // set by `_processAttachments`
      filePath: test.location.file,
      projectName: test.parent.project()?.name,
      repeatEachIndex: test.repeatEachIndex,
      attempt: result.retry + 1,
      source: this.getSource(test)
    };
    const { events, filenames, stacks } = this._processAttachments(testData, result.attachments);
    const relativePath = test.titlePath()[2];
    let playwrightMetadata;
    if (this.captureTestFile) {
      playwrightMetadata = {
        "x-replay-playwright": {
          sources: Object.fromEntries(
            [...filenames].map((filename) => {
              try {
                return [filename, fs.readFileSync(filename, "utf8")];
              } catch (e) {
                logger.logError("PlaywrightReporter:FailedToReadPlaywrightTestSource", {
                  filename,
                  error: e
                });
                return [filename, void 0];
              }
            })
          ),
          stacks
        }
      };
    }
    const tests = [
      {
        id: 0,
        attempt: testData.attempt,
        source: testData.source,
        executionGroupId: String(testData.repeatEachIndex),
        executionId: testData.executionId,
        maxAttempts: test.retries + 1,
        approximateDuration: test.results.reduce((acc, r) => acc + r.duration, 0),
        result: status === "interrupted" ? "unknown" : status,
        error: result.error ? {
          name: "Error",
          message: extractErrorMessage(result.error),
          line: result.error.location?.line ?? 0,
          column: result.error.location?.column ?? 0
        } : null,
        events
      }
    ];
    const recordings = this.reporter.getRecordingsForTest(tests);
    for (let i = 0; i < recordings.length; i++) {
      const recording = recordings[i];
      test.annotations.push({
        type: "Replay recording" + (i > 0 ? ` ${i + 1}` : ""),
        description: `https://app.replay.io/recording/${recording.id}`
      });
    }
    this.reporter.onTestEnd({
      tests,
      specFile: relativePath,
      replayTitle: test.title,
      extraMetadata: playwrightMetadata
    });
  }
  async onEnd() {
    try {
      await this.reporter.onEnd();
      const didUseReplayBrowser = Object.values(this._executedProjects).some(
        ({ usesReplayBrowser }) => usesReplayBrowser
      );
      const isReplayBrowserInstalled = fs.existsSync(getRuntimePath.getRuntimePath());
      const output = [];
      if (!didUseReplayBrowser) {
        mixpanelClient.trackEvent("warning.reporter-used-without-replay-project");
        output.push(theme.emphasize("None of the configured projects ran using Replay Chromium."));
      }
      if (!isReplayBrowserInstalled) {
        if (didUseReplayBrowser) {
          mixpanelClient.trackEvent("warning.replay-browser-not-installed");
        }
        output.push(
          `To record tests with Replay, you need to install the Replay browser: ${theme.highlight(
            "npx replayio install"
          )}`
        );
      }
      if (output.length) {
        output.push(
          `Learn more at ${theme.link(
            "https://docs.replay.io/reference/test-runners/playwright/overview"
          )}`
        );
        output.forEach((line, index) => {
          if (index > 0) {
            console.log("[replay.io]:");
          }
          console.warn(`[replay.io]: ${line}`);
        });
      }
      console.log("");
    } finally {
      await waitForExitTasks.waitForExitTasks();
    }
  }
  parseArguments(apiName, params) {
    logger.logInfo("PlaywrightReporter:ParseArguments", { apiName, params });
    if (!params || typeof params !== "object") {
      return [];
    }
    switch (apiName) {
      case "page.goto":
        return [params.url];
      case "page.evaluate":
        return [];
      case "locator.getAttribute":
        return [params.selector, params.name];
      case "mouse.move":
        return [JSON.stringify(params)];
      case "locator.hover":
        return [params.selector, String(params.force)];
      case "expect.toBeVisible":
        return [params.selector, params.expression, String(params.isNot)];
      case "keyboard.type":
        return [params.text];
      case "keyboard.down":
      case "keyboard.up":
        return [params.key];
      case "locator.evaluate":
      case "locator.scrollIntoViewIfNeeded":
        return [params.selector, params.state];
      default:
        return params.selector ? [params.selector] : [];
    }
  }
}

exports.default = ReplayPlaywrightReporter;

'use strict';

var test = require('@playwright/test');
var logger = require('./_bundled/@replay-cli/shared/logger.js');
require('node-fetch');
var metadata = require('./_bundled/@replayio/test-utils/metadata.js');
require('node:os');
var reporter = require('./_bundled/@replayio/test-utils/reporter.js');
require('sha-1');
var assert = require('node:assert/strict');
var constants = require('./constants.js');
var error = require('./error.js');
var fs = require('node:fs');
var uuid = require('uuid');
var path = require('node:path');
var stackTrace = require('./stackTrace.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);

const baseId = uuid.v4();
const workerIndex = +(process.env.TEST_WORKER_INDEX || 0);
const metadataFilePath = metadata.getMetadataFilePath("PLAYWRIGHT", workerIndex);
function getBaseMetadata() {
  let baseMetadata = process.env.PLAYWRIGHT_REPLAY_METADATA || process.env.RECORD_REPLAY_METADATA;
  if (baseMetadata && typeof baseMetadata === "string") {
    try {
      return JSON.parse(baseMetadata);
    } catch (error) {
      logger.logError("ReplayFixture:FailedParseBaseMetadata", { error, baseMetadata });
    }
  }
  return {};
}
function ReplayAddAnnotation([event, id, data]) {
  window.__RECORD_REPLAY_ANNOTATION_HOOK__?.("replay-playwright", {
    event,
    id,
    data: data ? JSON.parse(data) : void 0
  });
}
function isReplayAnnotation(params) {
  return params?.expression?.includes("ReplayAddAnnotation");
}
function parseLocation(stack) {
  const pattern = /\/([^\/]+):(\d+):(\d+)$/;
  const firstLine = stack?.split("\n").find((l) => pattern.test(l));
  const match = firstLine?.match(pattern);
  if (!match) {
    return {
      line: void 0,
      column: void 0
    };
  }
  return {
    line: parseInt(match[2]),
    column: parseInt(match[3])
  };
}
function parseError(error) {
  const location = parseLocation(error.stack);
  return {
    name: "name" in error ? error.name : "Error",
    message: error.message ?? "Unknown",
    line: location?.line,
    column: location?.column
  };
}
const fixtureStates = /* @__PURE__ */ new WeakMap();
function getFixtureState(testInfo) {
  let state = fixtureStates.get(testInfo);
  if (!state) {
    const attempt = testInfo.retry + 1;
    const testData = {
      executionId: `${baseId}-${testInfo.testId}-${testInfo.repeatEachIndex}-${attempt}`,
      filePath: testInfo.file,
      projectName: testInfo.project.name,
      repeatEachIndex: testInfo.repeatEachIndex,
      attempt,
      source: {
        title: testInfo.title,
        // this one only drops the filename (first segment) and the test title (last segment)
        // it's different from the one in the reporter, since the "root" suites are just the file suites created here:
        // https://github.com/microsoft/playwright/blob/73285245566bdce80bab736577e9bc278d5cf4bf/packages/playwright/src/common/testLoader.ts#L38
        // in this context they are not attached to the root and project suites
        scope: testInfo.titlePath.slice(1, -1)
      }
    };
    state = {
      expectSteps: /* @__PURE__ */ new Set(),
      ignoredSteps: /* @__PURE__ */ new Set(),
      testData
    };
    fixtureStates.set(testInfo, state);
  }
  return state;
}
const patchedTestInfos = /* @__PURE__ */ new WeakSet();
async function replayFixture({ playwright, browser }, use, testInfo) {
  const { expectSteps, ignoredSteps, testData } = getFixtureState(testInfo);
  if (!patchedTestInfos.has(testInfo)) {
    patchedTestInfos.add(testInfo);
    const addStep = testInfo._addStep;
    testInfo._addStep = function(data, ...rest) {
      if (data.category === "expect") {
        let frames = data.location ? [data.location] : void 0;
        if (!frames) {
          const filteredStack = stackTrace.filteredStackTrace(stackTrace.captureRawStack());
          data.location = filteredStack[0];
          frames = filteredStack;
        }
        const step = addStep.call(this, data, ...rest);
        expectSteps.add(step.stepId);
        handlePlaywrightEvent({
          event: "step:start",
          id: step.stepId,
          params: step.params,
          detail: {
            apiName: "expect",
            category: step.category,
            title: step.title,
            params: step.params || {},
            frames,
            hook: getCurrentHookType()
          }
        }).catch((err) => {
          logger.logError("ReplayFixture:FailedToAddExpectStep", { error: err });
        });
        return step;
      }
      return addStep.call(this, data, ...rest);
    };
    const onStepEnd = testInfo._onStepEnd;
    testInfo._onStepEnd = function(...args) {
      onStepEnd.call(this, ...args);
      const [payload] = args;
      if (expectSteps.has(payload.stepId)) {
        handlePlaywrightEvent({
          event: "step:end",
          id: payload.stepId,
          params: void 0,
          detail: {
            error: payload.error ? parseError(payload.error) : null
          }
        }).catch((err) => {
          logger.logError("ReplayFixture:FailedToAddExpectStepEnd", { error: err });
        });
      }
    };
  }
  function getCurrentHookType() {
    return testInfo._currentHookType();
  }
  logger.logInfo("ReplayFixture:SettingUp");
  async function addAnnotation(event, id, detail) {
    if (!id) {
      return;
    }
    return Promise.allSettled(
      browser.contexts().flatMap((context) => {
        return context.pages().flatMap(async (page) => {
          try {
            await page.evaluate(ReplayAddAnnotation, [
              event,
              id,
              JSON.stringify({ ...detail, test: testData })
            ]);
          } catch (error) {
            logger.logError("ReplayFixture:FailedToAddAnnotation", { error });
          }
        });
      })
    );
  }
  async function handlePlaywrightEvent({
    detail,
    ...data
  }) {
    try {
      assert__default.default(
        data.id != null,
        new reporter.ReporterError(error.Errors.MissingCurrentStep, "No current step for API call end")
      );
      testInfo.attach(`replay:${data.event}`, {
        body: JSON.stringify({
          ...detail,
          ...data
        }),
        contentType: constants.REPLAY_CONTENT_TYPE
      });
      return addAnnotation(data.event, data.id, detail);
    } catch (error$1) {
      let reporterError;
      if (error$1 instanceof reporter.ReporterError) {
        reporterError = error$1;
      } else if (error$1 instanceof Error) {
        reporterError = new reporter.ReporterError(error.Errors.UnexpectedError, error$1.message, {
          stack: error$1.stack
        });
      } else {
        reporterError = new reporter.ReporterError(error.Errors.UnexpectedError, "Unknown", { error: error$1 });
      }
      testInfo.attach("replay:step:error", {
        body: JSON.stringify(reporterError.valueOf()),
        contentType: constants.REPLAY_CONTENT_TYPE
      });
    }
  }
  const csiListener = {
    onApiCallBegin: ({ userData, params, apiName, frames }) => {
      const step = userData;
      if (!step?.stepId) {
        return;
      }
      if (isReplayAnnotation(params)) {
        ignoredSteps.add(step.stepId);
        return;
      }
      if (expectSteps.has(step.stepId)) {
        return;
      }
      if (!frames.length) {
        ignoredSteps.add(step.stepId);
        return;
      }
      return handlePlaywrightEvent({
        event: "step:start",
        id: step.stepId,
        params,
        detail: {
          apiName,
          category: step.category,
          frames,
          params: params ?? {},
          title: step.title,
          hook: getCurrentHookType()
        }
      });
    },
    onApiCallEnd: ({ userData, error, params }) => {
      const step = userData;
      if (!step?.stepId || ignoredSteps.has(step.stepId)) {
        return;
      }
      return handlePlaywrightEvent({
        event: "step:end",
        id: step.stepId,
        params,
        detail: {
          error: error ? parseError(error) : null
        }
      });
    }
  };
  const clientInstrumentation = playwright._instrumentation;
  clientInstrumentation.addListener(csiListener);
  try {
    const metadata = {
      ...getBaseMetadata(),
      "x-replay-test": {
        id: testData.executionId
      }
    };
    logger.logInfo("ReplayFixture:WillWriteMetadata", { metadataFilePath, metadata });
    fs.mkdirSync(path.dirname(metadataFilePath), { recursive: true });
    fs.writeFileSync(metadataFilePath, JSON.stringify(metadata, void 0, 2));
  } catch (error) {
    logger.logError("ReplayFixture:InitReplayMetadataFailed", {
      error
    });
  }
  testInfo.attach(`replay:test:start`, {
    body: JSON.stringify({
      executionId: testData.executionId
    }),
    contentType: constants.REPLAY_CONTENT_TYPE
  });
  await use();
  clientInstrumentation.removeListener(csiListener);
}
function addReplayFixture() {
  const testTypeSymbol = Object.getOwnPropertySymbols(test.test).find((s) => s.description === "testType");
  const fixtures = testTypeSymbol ? test.test[testTypeSymbol]?.fixtures : null;
  if (!fixtures) {
    logger.logError("ReplayFixture:FailedToInject");
    return;
  }
  fixtures.push({
    fixtures: {
      _replay: [
        replayFixture,
        {
          // "all-hooks-included" is supported since Playwright 1.23.0
          // https://github.com/microsoft/playwright/pull/14104
          auto: "all-hooks-included",
          _title: "Replay.io fixture"
        }
      ]
    }
  });
}

exports.addReplayFixture = addReplayFixture;
exports.metadataFilePath = metadataFilePath;
exports.replayFixture = replayFixture;

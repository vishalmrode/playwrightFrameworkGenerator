import { Properties } from "../../@replay-cli/shared/mixpanelClient";
import type { TestMetadataV2 } from "../../@replay-cli/shared/recording/metadata/legacy/test/v2";
import { UnstructuredMetadata } from "../../@replay-cli/shared/recording/types";
import type { RecordingEntry, ReplayReporterConfig } from "./types";
export interface TestRunner {
    name: string;
    version: string | undefined;
    plugin: string;
}
export type UserActionEvent = TestMetadataV2.UserActionEvent;
export type Test = TestMetadataV2.Test;
export type TestResult = TestMetadataV2.TestResult;
export type TestError = TestMetadataV2.TestError;
export type TestRun = TestMetadataV2.TestRun;
type PendingWorkType = "test-run" | "test-run-tests" | "post-test";
export type PendingWorkError<K extends PendingWorkType, TErrorData = {}> = TErrorData & {
    type: K;
    error: Error;
};
type PendingWorkEntry<TType extends PendingWorkType, TSuccessData = {}, TErrorData = {}> = PendingWorkError<TType, TErrorData> | (TSuccessData & {
    type: TType;
    error?: never;
});
type TestRunPendingWork = PendingWorkEntry<"test-run", {
    id: string;
    phase: "start" | "complete";
}>;
type TestRunTestsPendingWork = PendingWorkEntry<"test-run-tests">;
type PostTestPendingWork = PendingWorkEntry<"post-test", {
    recordings: RecordingEntry[];
    testRun: TestRun;
}>;
export type PendingWork = TestRunPendingWork | TestRunTestsPendingWork | PostTestPendingWork;
export declare class ReporterError extends Error {
    code: number;
    detail: any;
    constructor(code: number, message: string, detail?: any);
    valueOf(): {
        code: number;
        name: string;
        message: string;
        detail: any;
    };
}
export default class ReplayReporter<TRecordingMetadata extends UnstructuredMetadata = UnstructuredMetadata> {
    baseTestRunId: string;
    private _baseMetadata;
    private _testRunShardId;
    private _schemaVersion;
    private _runTitle?;
    private _runner;
    private _errors;
    private _apiKey?;
    private _pendingWork;
    private _upload;
    private _filter?;
    private _minimizeUploads;
    private _uploadableResults;
    private _testRunShardIdPromise;
    private _uploadStatusThreshold;
    private _uploadWorker;
    private _uploadedRecordings;
    private _recordingMetadatas;
    constructor(runner: TestRunner, schemaVersion: string, config?: ReplayReporterConfig<TRecordingMetadata>);
    setTestRunnerVersion(version: TestRunner["version"]): void;
    setApiKey(apiKey: string): void;
    private _getResultFromResultCounts;
    private _summarizeResults;
    private _parseConfig;
    addError(error: Error | ReporterError, context?: Properties): void;
    setDiagnosticMetadata(metadata: Record<string, unknown>): void;
    onTestSuiteBegin(config?: ReplayReporterConfig<TRecordingMetadata>, metadataKey?: string): void;
    private _startTestRunShard;
    private _addTestsToShard;
    private _completeTestRunShard;
    onTestBegin(metadataFilePath?: string, testExecutionId?: string): void;
    onTestEnd({ tests, specFile, replayTitle, extraMetadata, runnerGroupKey, }: {
        tests: Test[];
        specFile: string;
        replayTitle?: string;
        extraMetadata?: Record<string, unknown>;
        runnerGroupKey?: string;
    }): void;
    private _uploadRecording;
    getRecordingsForTest(tests: {
        executionId: string;
    }[]): import("./legacy-cli/types").ExternalRecordingEntry[];
    private _buildTestMetadata;
    private _setRecordingMetadata;
    private _enqueuePostTestWork;
    private _storeUploadableTestResults;
    private _enqueueUploads;
    private _assignAggregateStatus;
    onEnd(): Promise<PendingWork[]>;
}
export {};

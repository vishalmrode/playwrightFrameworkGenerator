'use strict';

var fs = require('node:fs');
var generateDefaultTitle = require('./generateDefaultTitle.js');
var config = require('../../../@replay-cli/shared/recording/config.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);

function readRecordingFile() {
  if (!fs__default.default.existsSync(config.recordingLogPath)) {
    return [];
  }
  return fs__default.default.readFileSync(config.recordingLogPath, "utf8").split("\n");
}
function getBuildRuntime(buildId) {
  const match = /.*?-(.*?)-/.exec(buildId);
  return match ? match[1] : "unknown";
}
const RECORDING_LOG_KIND = [
  "createRecording",
  "addMetadata",
  "writeStarted",
  "sourcemapAdded",
  "originalSourceAdded",
  "writeFinished",
  "uploadStarted",
  "uploadFinished",
  "recordingUnusable",
  "crashed",
  "crashData",
  "crashUploaded"
];
function updateStatus(recording, status) {
  if (recording.status == "unusable" || recording.status == "crashUploaded" || recording.status == "crashed" && status != "crashUploaded") {
    return;
  }
  recording.status = status;
}
function readRecordings(includeHidden = false) {
  const recordings = [];
  const lines = readRecordingFile().map((line) => {
    try {
      return JSON.parse(line);
    } catch {
      return null;
    }
  }).filter((o) => o != null).sort((a, b) => RECORDING_LOG_KIND.indexOf(a.kind) - RECORDING_LOG_KIND.indexOf(b.kind));
  for (const obj of lines) {
    switch (obj.kind) {
      case "createRecording": {
        const { id, timestamp, buildId } = obj;
        recordings.push({
          id,
          createTime: new Date(timestamp),
          buildId,
          runtime: getBuildRuntime(buildId),
          metadata: {},
          sourcemaps: [],
          // We use an unknown status after the createRecording event because
          // there should always be later events describing what happened to the
          // recording.
          status: "unknown"
        });
        break;
      }
      case "addMetadata": {
        const { id, metadata } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          Object.assign(recording.metadata, metadata);
          if (!recording.metadata.title) {
            recording.metadata.title = generateDefaultTitle.generateDefaultTitle(recording.metadata);
          }
        }
        break;
      }
      case "writeStarted": {
        const { id, path } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "startedWrite");
          recording.path = path;
        }
        break;
      }
      case "writeFinished": {
        const { id } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "onDisk");
        }
        break;
      }
      case "uploadStarted": {
        const { id, server, recordingId } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "startedUpload");
          recording.server = server;
          recording.recordingId = recordingId;
        }
        break;
      }
      case "uploadFinished": {
        const { id } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "uploaded");
        }
        break;
      }
      case "recordingUnusable": {
        const { id, reason } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "unusable");
          recording.unusableReason = reason;
        }
        break;
      }
      case "crashed": {
        const { id } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "crashed");
        }
        break;
      }
      case "crashData": {
        const { id, data } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          if (!recording.crashData) {
            recording.crashData = [];
          }
          recording.crashData.push(data);
        }
        break;
      }
      case "crashUploaded": {
        const { id } = obj;
        const recording = recordings.find((r) => r.id == id);
        if (recording) {
          updateStatus(recording, "crashUploaded");
        }
        break;
      }
      case "sourcemapAdded": {
        const {
          id,
          recordingId,
          path,
          baseURL,
          targetContentHash,
          targetURLHash,
          targetMapURLHash
        } = obj;
        const recording = recordings.find((r) => r.id == recordingId);
        if (recording) {
          recording.sourcemaps.push({
            id,
            path,
            baseURL,
            targetContentHash,
            targetURLHash,
            targetMapURLHash,
            originalSources: []
          });
        }
        break;
      }
      case "originalSourceAdded": {
        const { recordingId, path, parentId, parentOffset } = obj;
        const recording = recordings.find((r) => r.id === recordingId);
        if (recording) {
          const sourcemap = recording.sourcemaps.find((s) => s.id === parentId);
          if (sourcemap) {
            sourcemap.originalSources.push({
              path,
              parentOffset
            });
          }
        }
        break;
      }
    }
  }
  if (includeHidden) {
    return recordings;
  }
  return recordings.filter((r) => !(r.unusableReason || "").includes("No interesting content"));
}

exports.readRecordings = readRecordings;

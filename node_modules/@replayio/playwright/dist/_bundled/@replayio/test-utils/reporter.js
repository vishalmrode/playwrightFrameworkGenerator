'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var retryOnFailure = require('../../@replay-cli/shared/async/retryOnFailure.js');
var queryGraphQL = require('../../@replay-cli/shared/graphql/queryGraphQL.js');
var logger = require('../../@replay-cli/shared/logger.js');
var mixpanelClient = require('../../@replay-cli/shared/mixpanelClient.js');
var getRecordings = require('../../@replay-cli/shared/recording/getRecordings.js');
var addMetadata = require('../../@replay-cli/shared/recording/metadata/addMetadata.js');
var source = require('../../@replay-cli/shared/recording/metadata/legacy/source.js');
var index = require('../../@replay-cli/shared/recording/metadata/legacy/test/index.js');
var uploadWorker = require('../../@replay-cli/shared/recording/upload/uploadWorker.js');
var assert = require('node:assert/strict');
var node_child_process = require('node:child_process');
var fs = require('node:fs');
var path = require('node:path');
var uuid = require('uuid');
var getAccessToken = require('./getAccessToken.js');
var error = require('./legacy-cli/error.js');
var listAllRecordings = require('./legacy-cli/listAllRecordings.js');
var logging = require('./logging.js');
var metrics = require('./metrics.js');
var testId = require('./testId.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);

function last(arr) {
  return arr[arr.length - 1];
}
function logPendingWorkErrors(errors) {
  return errors.map((e) => `   - ${e.error.message}`);
}
function getTestResult(recording, metadatas) {
  const test = metadatas.get(recording.id)?.test;
  return !test ? "unknown" : test.result;
}
function getTestResultEmoji(recording, metadatas) {
  const result = getTestResult(recording, metadatas);
  switch (result) {
    case "unknown":
      return "\uFE56";
    case "failed":
    case "timedOut":
      return "\u274C";
    case "passed":
      return "\u2705";
    case "skipped":
      return "\u{1F937}";
  }
}
const resultOrder = ["failed", "timedOut", "passed", "skipped", "unknown"];
function sortRecordingsByResult(recordings, metadatas) {
  return [...recordings].sort((a, b) => {
    return resultOrder.indexOf(getTestResult(a, metadatas)) - resultOrder.indexOf(getTestResult(b, metadatas)) || (a.metadata.title || "").localeCompare(b.metadata.title || "");
  });
}
function parseRuntime(runtime) {
  return ["chromium", "gecko", "node"].find((r) => runtime?.includes(r));
}
function createGraphqlError(operation, errors) {
  const errorMessages = errors.map(error.getErrorMessage);
  logger.logError("GraphQlOperationFailed", { operation, errors: errors.map(error.getErrorMessage) });
  for (const error of errors) {
    switch (error.extensions?.code) {
      case "UNAUTHENTICATED":
        return new Error(error.message);
    }
  }
  return new Error(`GraphQL request for ${operation} failed (${errorMessages.join(", ")})`);
}
class ReporterError extends Error {
  code;
  detail;
  constructor(code, message, detail = null) {
    super();
    this.name = "ReporterError";
    this.code = code;
    this.message = message;
    this.detail = !detail || typeof detail === "string" ? detail : JSON.stringify(detail);
  }
  valueOf() {
    return {
      code: this.code,
      name: this.name,
      message: this.message,
      detail: this.detail
    };
  }
}
function getFallbackRunTitle() {
  if (process.env.CI) {
    return;
  }
  let gitChild;
  try {
    gitChild = node_child_process.spawnSync("git", ["rev-parse", "--abbrev-ref", "HEAD"]);
  } catch {
    return;
  }
  if (gitChild.status !== 0) {
    return;
  }
  return `(local) ${gitChild.stdout.toString().trim()} branch`;
}
class ReplayReporter {
  baseTestRunId = source.getTestRunIdFromEnvironment(process.env) || uuid.v4();
  _baseMetadata = null;
  _testRunShardId = null;
  _schemaVersion;
  _runTitle;
  _runner;
  _errors = [];
  _apiKey;
  _pendingWork = [];
  _upload = false;
  _filter;
  _minimizeUploads = false;
  _uploadableResults = /* @__PURE__ */ new Map();
  _testRunShardIdPromise = null;
  _uploadStatusThreshold = "none";
  _uploadWorker;
  _uploadedRecordings = /* @__PURE__ */ new Set();
  _recordingMetadatas = /* @__PURE__ */ new Map();
  constructor(runner, schemaVersion, config) {
    this._runner = runner;
    this._schemaVersion = schemaVersion;
    if (config) {
      const { metadataKey, ...rest } = config;
      this._parseConfig(rest, metadataKey);
    }
    if (config) {
      if (config.filter) {
        logger.logInfo("ReplayReporter:Config:HasFilter", {
          filter: config.filter.toString()
        });
      } else {
        logger.logInfo("ReplayReporter:Config:NoFilter");
      }
    }
  }
  setTestRunnerVersion(version) {
    this._runner = {
      ...this._runner,
      version
    };
  }
  setApiKey(apiKey) {
    this._apiKey = apiKey;
  }
  _getResultFromResultCounts(resultCounts) {
    const { failed, passed, skipped, timedOut } = resultCounts;
    if (failed > 0) {
      return "failed";
    } else if (timedOut > 0) {
      return "timedOut";
    } else if (passed > 0) {
      return "passed";
    } else if (skipped > 0) {
      return "skipped";
    } else {
      return "unknown";
    }
  }
  _summarizeResults(tests) {
    let approximateDuration = 0;
    let resultCounts = {
      failed: 0,
      passed: 0,
      skipped: 0,
      timedOut: 0,
      unknown: 0
    };
    const testsById = {};
    tests.forEach((test) => {
      if (!testsById[test.id] || test.attempt > testsById[test.id].attempt) {
        testsById[test.id] = test;
      }
    });
    Object.values(testsById).forEach((t) => {
      approximateDuration += t.approximateDuration || 0;
      switch (t.result) {
        case "failed":
          resultCounts.failed++;
          break;
        case "passed":
          resultCounts.passed++;
          break;
        case "skipped":
          resultCounts.skipped++;
          break;
        case "timedOut":
          resultCounts.timedOut++;
          break;
        default:
          resultCounts.unknown++;
      }
    });
    return { approximateDuration, resultCounts };
  }
  _parseConfig(config = {}, metadataKey) {
    this._apiKey = getAccessToken.getAccessToken(config);
    this._upload = "upload" in config ? !!config.upload : !!process.env.REPLAY_UPLOAD;
    if (this._upload) {
      if (!this._apiKey) {
        throw new Error(
          `\`@replayio/${this._runner.name}/reporter\` requires an API key to upload recordings. Either pass a value to the apiKey plugin configuration or set the REPLAY_API_KEY environment variable`
        );
      }
      if (typeof config.upload === "object") {
        this._minimizeUploads = !!config.upload.minimizeUploads;
        this._uploadStatusThreshold = config.upload.statusThreshold ?? "all";
      } else {
        this._uploadStatusThreshold = "all";
      }
      this._uploadWorker = uploadWorker.createUploadWorker({
        accessToken: this._apiKey,
        deleteOnSuccess: true,
        processingBehavior: "do-not-process"
      });
    }
    this._runTitle = process.env.REPLAY_METADATA_TEST_RUN_TITLE || process.env.RECORD_REPLAY_TEST_RUN_TITLE || process.env.RECORD_REPLAY_METADATA_TEST_RUN_TITLE || config.runTitle || getFallbackRunTitle();
    this._filter = config.filter;
    if (metadataKey && process.env[metadataKey] && process.env.RECORD_REPLAY_METADATA) {
      console.warn(
        `Cannot set metadata via both RECORD_REPLAY_METADATA and ${metadataKey}. Using ${metadataKey}.`
      );
    }
    const baseMetadata = metadataKey && process.env[metadataKey] || process.env.RECORD_REPLAY_METADATA || config.metadata || null;
    if (baseMetadata) {
      if (typeof baseMetadata === "string") {
        try {
          this._baseMetadata = JSON.parse(baseMetadata);
        } catch {
          console.warn("Failed to parse Replay metadata");
        }
      } else {
        this._baseMetadata = baseMetadata;
      }
    }
  }
  addError(error, context) {
    logger.logError("AddError", { error });
    mixpanelClient.trackEvent(`test-suite.error.${error.name}`, { context, error });
    if (error.name === "ReporterError") {
      this._errors.push(error);
    } else {
      this._errors.push(new ReporterError(-1, "Unexpected error", error));
    }
  }
  setDiagnosticMetadata(metadata) {
    this._baseMetadata = {
      ...this._baseMetadata,
      "x-replay-diagnostics": metadata
    };
    mixpanelClient.appendAdditionalProperties({ baseMetadata: this._baseMetadata });
  }
  onTestSuiteBegin(config, metadataKey) {
    if (config || metadataKey) {
      this._parseConfig(config, metadataKey);
    }
    logger.logInfo("OnTestSuiteBegin:ReporterConfiguration", {
      baseId: this.baseTestRunId,
      runTitle: this._runTitle,
      runner: this._runner,
      baseMetadata: this._baseMetadata,
      upload: this._upload,
      hasApiKey: !!this._apiKey,
      hasFilter: !!this._filter
    });
    mixpanelClient.trackEvent("test-suite.begin", {
      baseId: this.baseTestRunId,
      runTitle: this._runTitle,
      upload: this._upload,
      hasFilter: !!this._filter
    });
    if (!this._apiKey) {
      logger.logInfo("OnTestSuiteBegin:NoApiKey");
      mixpanelClient.trackEvent("test-suite.no-api-key");
      return;
    }
  }
  async _startTestRunShard() {
    logger.logInfo("StartTestRunShard:Started");
    let metadata = {};
    try {
      metadata = await source.init();
    } catch (error) {
      logger.logError("StartTestRunShard:InitMetadataFailed", {
        error
      });
    }
    const { REPLAY_METADATA_TEST_RUN_MODE, RECORD_REPLAY_METADATA_TEST_RUN_MODE } = process.env;
    const testRun = {
      runnerName: this._runner.name,
      runnerVersion: this._runner.version,
      repository: metadata.source?.repository ?? null,
      title: this._runTitle ?? null,
      mode: REPLAY_METADATA_TEST_RUN_MODE ?? RECORD_REPLAY_METADATA_TEST_RUN_MODE ?? null,
      branch: metadata.source?.branch ?? null,
      pullRequestId: metadata.source?.merge?.id ?? null,
      pullRequestTitle: metadata.source?.merge?.title ?? null,
      commitId: metadata.source?.commit?.id ?? null,
      commitTitle: metadata.source?.commit?.title ?? null,
      commitUser: metadata.source?.commit?.user ?? null,
      triggerUrl: metadata.source?.trigger?.url ?? null,
      triggerUser: metadata.source?.trigger?.user ?? null,
      triggerReason: metadata.source?.trigger?.workflow ?? null
    };
    logger.logInfo("StartTestRunShard:WillCreateShard", { baseId: this.baseTestRunId });
    try {
      return retryOnFailure.retryWithExponentialBackoff(async () => {
        const resp = await queryGraphQL.queryGraphQL(
          "CreateTestRunShard",
          `
          mutation CreateTestRunShard($clientKey: String!, $testRun: TestRunShardInput!) {
            startTestRunShard(input: {
              clientKey: $clientKey,
              testRun: $testRun
            }) {
              success
              testRunShardId
            }
          }
        `,
          {
            clientKey: this.baseTestRunId,
            testRun
          },
          this._apiKey
        );
        if (resp.errors) {
          return {
            type: "test-run",
            error: createGraphqlError("CreateTestRunShard", resp.errors)
          };
        }
        const testRunShardId = resp.data.startTestRunShard.testRunShardId;
        if (!testRunShardId) {
          return {
            type: "test-run",
            error: new Error("Unexpected error retrieving test run shard id")
          };
        }
        logger.logInfo("StartTestRunShard:CreatedShard", {
          testRunShardId,
          baseId: this.baseTestRunId
        });
        this._testRunShardId = testRunShardId;
        return {
          type: "test-run",
          id: testRunShardId,
          phase: "start"
        };
      });
    } catch (error$1) {
      logger.logError("StartTestRunShardFailed", {
        error: error$1
      });
      return {
        type: "test-run",
        error: new Error(`Unexpected error starting test run shard: ${error.getErrorMessage(error$1)}`)
      };
    }
  }
  async _addTestsToShard(tests) {
    logger.logInfo("AddTestsToSharded", { testsLength: tests.length });
    let testRunShardId = this._testRunShardId;
    if (!testRunShardId) {
      await this._testRunShardIdPromise;
      testRunShardId = this._testRunShardId;
      if (!testRunShardId) {
        return;
      }
    }
    logger.logInfo("AddTestsToShard:WillAddTests", {
      testsLength: tests.length,
      testRunShardId
    });
    try {
      await retryOnFailure.retryWithExponentialBackoff(async () => {
        const resp = await queryGraphQL.queryGraphQL(
          "AddTestsToShard",
          `
          mutation AddTestsToShard($testRunShardId: String!, $tests: [TestRunTestInputType!]!) {
            addTestsToShard(input: {
              testRunShardId: $testRunShardId,
              tests: $tests
            }) {
              success
            }
          }
        `,
          {
            testRunShardId,
            tests
          },
          this._apiKey
        );
        if (resp.errors) {
          return {
            type: "test-run-tests",
            error: createGraphqlError("AddTestsToShard", resp.errors)
          };
        }
      });
      logger.logInfo("AddTestsToShard:AddedTests", { testRunShardId });
      return {
        type: "test-run-tests"
      };
    } catch (error$1) {
      logger.logError("AddTestsToShard:Failed", { error: error$1 });
      return {
        type: "test-run-tests",
        error: new Error(`Unexpected error adding tests to run: ${error.getErrorMessage(error$1)}`)
      };
    }
  }
  async _completeTestRunShard() {
    logger.logInfo("CompleteTestRunShard:Started");
    let testRunShardId = this._testRunShardId;
    if (!testRunShardId) {
      await this._testRunShardIdPromise;
      testRunShardId = this._testRunShardId;
      if (!testRunShardId) {
        return;
      }
    }
    logger.logInfo("CompleteTestRunShard:WillMarkCompleted", { testRunShardId });
    try {
      await retryOnFailure.retryWithExponentialBackoff(async () => {
        const resp = await queryGraphQL.queryGraphQL(
          "CompleteTestRunShard",
          `
        mutation CompleteTestRunShard($testRunShardId: String!) {
          completeTestRunShard(input: {
            testRunShardId: $testRunShardId
          }) {
            success
          }
        }
      `,
          {
            testRunShardId
          },
          this._apiKey
        );
        if (resp.errors) {
          return {
            type: "test-run",
            error: createGraphqlError("CompleteTestRunShard", resp.errors)
          };
        }
      });
      logger.logInfo("CompleteTestRunShard:MarkedComplete", { testRunShardId });
      return {
        type: "test-run",
        id: testRunShardId,
        phase: "complete"
      };
    } catch (error$1) {
      logger.logError("CompleteTestRunShard:Failed", {
        error: error$1,
        testRunShardId
      });
      return {
        type: "test-run",
        error: new Error(`Unexpected error completing test run shard: ${error.getErrorMessage(error$1)}`)
      };
    }
  }
  onTestBegin(metadataFilePath, testExecutionId) {
    logger.logInfo("OnTestBegin:Started", { testExecutionId });
    if (this._apiKey && !this._testRunShardIdPromise) {
      this._testRunShardIdPromise = this._startTestRunShard();
      this._pendingWork.push(this._testRunShardIdPromise);
    }
    this._errors = [];
    if (!metadataFilePath) {
      return;
    }
    assert__default.default(
      testExecutionId,
      "Calling `onTestBegin` with `metadataFilePath` requires `testExecutionId` to be passed too."
    );
    const metadata = {
      ...this._baseMetadata || {},
      "x-replay-test": {
        id: testExecutionId
      }
    };
    logger.logInfo("OnTestBegin:WillWriteMetadata", { metadataFilePath, metadata });
    try {
      fs.mkdirSync(path.dirname(metadataFilePath), { recursive: true });
      fs.writeFileSync(metadataFilePath, JSON.stringify(metadata, void 0, 2), {});
    } catch (error) {
      logger.logError("OnTestBegin:InitReplayMetadataFailed", {
        error
      });
    }
  }
  onTestEnd({
    tests,
    specFile,
    replayTitle,
    extraMetadata,
    runnerGroupKey
  }) {
    logger.logInfo("OnTestEnd:Started", { specFile });
    mixpanelClient.trackEvent("test-suite.test-end", {
      replayTitle,
      specFile
    });
    if (tests.length === 0) {
      logger.logInfo("OnTestEnd:NoTestsFound", { specFile });
      return;
    }
    this._pendingWork.push(
      this._enqueuePostTestWork(tests, specFile, runnerGroupKey, replayTitle, extraMetadata)
    );
  }
  async _uploadRecording(recording) {
    if (this._uploadStatusThreshold === "none" || !this._apiKey || !this._uploadWorker) {
      return;
    }
    if (this._uploadedRecordings.has(recording.id)) {
      logger.logInfo("UploadRecording:AlreadyScheduled", {
        recordingId: recording.id
      });
      return;
    }
    const uploadableRecording = getRecordings.getRecordings().find((r) => r.id === recording.id);
    if (!uploadableRecording) {
      logger.logInfo("UploadRecording:NoUploadableRecording", {
        recordingId: recording.id
      });
      return;
    }
    this._uploadedRecordings.add(uploadableRecording.id);
    this._uploadWorker.upload(uploadableRecording);
  }
  getRecordingsForTest(tests) {
    const filter = `function($v) { $v.metadata.\`x-replay-test\`.id in ${JSON.stringify([
      ...tests.map((test) => test.executionId)
    ])} and $not($exists($v.metadata.test)) }`;
    const recordings = listAllRecordings.listAllRecordings({
      all: false,
      filter
    });
    logger.logInfo("GetRecordingsForTest:FoundRecordings", {
      recordingsLength: recordings.length,
      filter
    });
    return recordings;
  }
  _buildTestMetadata(tests, specFile) {
    const test = tests[0];
    const { approximateDuration, resultCounts } = this._summarizeResults(tests);
    const result = this._getResultFromResultCounts(resultCounts);
    const source = {
      path: specFile,
      title: test.source.title
    };
    const metadata = {
      approximateDuration,
      source,
      result,
      resultCounts,
      run: {
        id: this.baseTestRunId,
        title: this._runTitle
      },
      tests,
      environment: {
        errors: this._errors.map((e) => e.valueOf()),
        pluginVersion: this._runner.plugin,
        testRunner: {
          name: this._runner.name,
          version: this._runner.version || "unknown"
        }
      },
      schemaVersion: this._schemaVersion
    };
    return metadata;
  }
  async _setRecordingMetadata(recordings, testRun, replayTitle, extraMetadata) {
    logger.logInfo("SetRecordingMetadata:Started", {
      recordingIds: recordings.map((r) => r.id),
      errorLength: this._errors.length
    });
    mixpanelClient.trackEvent("test-suite.metadata", {
      numErrors: this._errors.length,
      numRecordings: recordings.length,
      replayTitle,
      extraMetadata
    });
    const validatedTestMetadata = index.init({
      ...testRun,
      schemaVersion: this._schemaVersion
    });
    let mergedMetadata = {
      title: replayTitle || testRun.source.title,
      ...extraMetadata,
      ...validatedTestMetadata
    };
    try {
      const validatedSourceMetadata = await source.init();
      mergedMetadata = {
        ...mergedMetadata,
        ...validatedSourceMetadata
      };
    } catch (error) {
      logger.logError("SetRecordingMetadata:GenerateSourceMetadataFailed", {
        error
      });
    }
    recordings.forEach((rec) => {
      this._recordingMetadatas.set(rec.id, mergedMetadata);
      addMetadata.addMetadata(rec.id, mergedMetadata);
    });
    const allRecordings = listAllRecordings.listAllRecordings({ all: true });
    return allRecordings.filter(
      (recordingWithMetadata) => recordings.some((r) => r.id === recordingWithMetadata.id)
    );
  }
  async _enqueuePostTestWork(tests, specFile, runnerGroupKey, replayTitle, extraMetadata) {
    try {
      const runnerGroupId = runnerGroupKey ? testId.generateOpaqueId(runnerGroupKey) : null;
      const recordings = this.getRecordingsForTest(tests);
      const recordingIds = recordings.map((r) => r.id);
      const testInputs = tests.map((t) => {
        const testId$1 = testId.buildTestId(specFile, t);
        if (!testId$1) {
          throw new Error("Failed to generate test id for test");
        }
        return {
          testId: testId$1,
          runnerGroupId,
          index: t.id,
          attempt: t.attempt,
          scope: t.source.scope,
          title: t.source.title,
          sourcePath: specFile,
          result: t.result,
          error: t.error ? t.error.message : null,
          duration: t.approximateDuration,
          recordingIds
        };
      });
      if (this._apiKey) {
        this._pendingWork.push(this._addTestsToShard(testInputs));
      } else {
        logger.logInfo("EnqueuePostTestWork:WillSkipAddTests");
      }
      const testMetadata2 = this._buildTestMetadata(tests, specFile);
      if (recordings.length > 0) {
        const recordingsWithMetadata = await this._setRecordingMetadata(
          recordings,
          testMetadata2,
          replayTitle,
          extraMetadata
        );
        this._storeUploadableTestResults(
          tests.map((test) => {
            return {
              executionGroupId: test.executionGroupId,
              attempt: test.attempt,
              maxAttempts: test.maxAttempts,
              recordings: recordingsWithMetadata,
              result: test.result,
              testId: testId.buildTestId(specFile, test)
            };
          })
        );
      }
      const firstRecording = recordings[0];
      metrics.pingTestMetrics(
        firstRecording?.id,
        this.baseTestRunId,
        {
          id: testMetadata2.source.path + "#" + testMetadata2.source.title,
          source: testMetadata2.source,
          approximateDuration: testMetadata2.approximateDuration,
          recorded: firstRecording !== void 0,
          runtime: parseRuntime(firstRecording?.runtime),
          runner: this._runner.name,
          result: testMetadata2.result
        },
        this._apiKey
      );
      return {
        type: "post-test",
        recordings,
        testRun: testMetadata2
      };
    } catch (error$1) {
      logger.logError("EnqueuePostTestWork:Failed", { error: error$1 });
      return {
        type: "post-test",
        error: new Error(`Error setting metadata and uploading replays: ${error.getErrorMessage(error$1)}`)
      };
    }
  }
  _storeUploadableTestResults(results) {
    if (this._uploadStatusThreshold === "none" || !this._apiKey) {
      return;
    }
    for (const result of results) {
      if (result.result === "skipped") {
        continue;
      }
      let uploadableResults = this._uploadableResults.get(result.testId);
      if (!uploadableResults) {
        uploadableResults = {
          executions: {},
          aggregateStatus: void 0,
          didUploadStatuses: {
            passed: false,
            failed: false
          }
        };
        this._uploadableResults.set(result.testId, uploadableResults);
      }
      let executions = uploadableResults.executions[result.executionGroupId];
      if (!executions) {
        executions = [];
        uploadableResults.executions[result.executionGroupId] = executions;
      }
      executions.push(result);
      if (result.result === "passed" || result.attempt >= result.maxAttempts) {
        this._enqueueUploads(uploadableResults, result.executionGroupId);
      }
    }
  }
  _enqueueUploads(result, executionGroupId) {
    if (this._uploadStatusThreshold === "none" || !this._apiKey) {
      return;
    }
    const executions = result.executions[executionGroupId];
    const latestExecution = last(executions);
    assert__default.default(!!latestExecution, "Expected at least one execution in the list");
    let toUpload = [];
    const aggregateStatus = this._assignAggregateStatus(result, executions);
    switch (aggregateStatus) {
      case "failed": {
        if (!this._minimizeUploads) {
          result.didUploadStatuses.failed = true;
          toUpload.push(...executions);
          break;
        }
        if (result.didUploadStatuses.failed) {
          break;
        }
        result.didUploadStatuses.failed = true;
        toUpload.push(latestExecution);
        break;
      }
      case "flaky": {
        if (this._uploadStatusThreshold === "failed") {
          break;
        }
        if (!this._minimizeUploads) {
          result.didUploadStatuses.failed ||= executions.some((r) => r.result !== "passed");
          result.didUploadStatuses.passed ||= executions.some((r) => r.result === "passed");
          toUpload.push(...executions);
        }
        if (!result.didUploadStatuses.failed) {
          const failedExecution = Object.values(result.executions).flatMap((e) => e).find((r) => r.result !== "passed");
          if (failedExecution) {
            result.didUploadStatuses.failed = true;
            toUpload.push(failedExecution);
          }
        }
        if (!result.didUploadStatuses.passed) {
          const passedExecution = Object.values(result.executions).flatMap((e) => e).find((r) => r.result === "passed");
          if (passedExecution) {
            result.didUploadStatuses.failed = true;
            toUpload.push(passedExecution);
          }
        }
        break;
      }
      case "passed": {
        if (this._uploadStatusThreshold !== "all") {
          break;
        }
        if (!this._minimizeUploads) {
          result.didUploadStatuses.passed = true;
          toUpload.push(...executions);
          break;
        }
        if (result.didUploadStatuses.passed) {
          break;
        }
        result.didUploadStatuses.passed = true;
        toUpload.push(latestExecution);
        break;
      }
    }
    const filteredRecordings = toUpload.flatMap((result2) => result2.recordings).filter((r) => this._filter ? this._filter(r) : true);
    for (const recording of filteredRecordings) {
      this._uploadRecording(recording);
    }
  }
  _assignAggregateStatus(result, newExecutions) {
    if (!result.aggregateStatus) {
      const latestExecution = last(newExecutions);
      assert__default.default(latestExecution, "Expected at least one execution in the list");
      result.aggregateStatus = latestExecution.result !== "passed" ? "failed" : newExecutions.length > 1 ? "flaky" : "passed";
      return result.aggregateStatus;
    }
    switch (result.aggregateStatus) {
      case "passed":
        if (newExecutions.some((r) => r.result !== "passed")) {
          result.aggregateStatus = "flaky";
        }
        return result.aggregateStatus;
      case "failed":
        if (newExecutions.some((r) => r.result === "passed")) {
          result.aggregateStatus = "flaky";
        }
        return result.aggregateStatus;
      case "flaky":
        return result.aggregateStatus;
    }
  }
  async onEnd() {
    logger.logInfo("OnEnd:Started");
    mixpanelClient.trackEvent("test-suite.ending", {
      minimizeUploads: this._minimizeUploads,
      numPendingWork: this._pendingWork.length,
      uploadStatusThreshold: this._uploadStatusThreshold
    });
    const output = [];
    let completedWork = [];
    if (this._pendingWork.length) {
      logging.log("Finishing up. This should only take a moment ...");
    }
    while (this._pendingWork.length) {
      const pendingWork = this._pendingWork;
      logger.logInfo("OnEnd:PendingWork", { pendingWorkLength: pendingWork.length });
      this._pendingWork = [];
      completedWork.push(...await Promise.allSettled(pendingWork));
    }
    if (this._apiKey) {
      const postSettledWork = await Promise.allSettled([this._completeTestRunShard()]);
      completedWork.push(...postSettledWork);
    } else {
      logger.logInfo("OnEnd:WillSkipCompletingTestRun");
    }
    const failures = completedWork.filter((r) => r.status === "rejected");
    if (failures.length > 0) {
      output.push("Encountered unexpected errors while processing replays");
      failures.forEach((f) => output.push(`  ${f.reason}`));
    }
    const results = completedWork.map((r) => r.status === "fulfilled" && r.value).filter((r) => !!r);
    const errors = {
      "post-test": [],
      "test-run": [],
      "test-run-tests": []
    };
    const uploads = await this._uploadWorker?.end();
    for (const r of results) {
      if ("error" in r) {
        errors[r.type].push(r);
      }
    }
    if (errors["post-test"].length > 0) {
      output.push(`
\u274C We encountered some unexpected errors processing your recordings`);
      output.push(...logPendingWorkErrors(errors["post-test"]));
    }
    if (errors["test-run-tests"].length > 0 || errors["test-run"].length > 0) {
      output.push("\n\u274C We encountered some unexpected errors creating your tests on replay.io");
      output.push(...logPendingWorkErrors(errors["test-run-tests"]));
      output.push(...logPendingWorkErrors(errors["test-run"]));
    }
    let numCrashed = 0;
    let numUploaded = 0;
    if (uploads?.length) {
      const failedUploads = uploads.filter((u) => u.uploadStatus === "failed");
      const uploaded = uploads.filter(
        (u) => u.recordingStatus !== "crashed" && u.uploadStatus === "uploaded"
      );
      const crashed = uploads.filter(
        (u) => u.recordingStatus === "crashed" && u.uploadStatus === "uploaded"
      );
      if (failedUploads.length > 0) {
        output.push(`
\u274C Failed to upload ${failedUploads.length} recordings:
`);
        failedUploads.forEach((recording) => {
          output.push(`   ${recording.metadata.title || "Unknown"}`);
          output.push(`      ${error.getErrorMessage(recording.uploadError)}
`);
        });
      }
      numCrashed = crashed.length;
      numUploaded = uploaded.length;
      if (uploaded.length > 0) {
        output.push(`
\u{1F680} Successfully uploaded ${uploads.length} recordings:`);
        const sortedUploads = sortRecordingsByResult(uploads, this._recordingMetadatas);
        sortedUploads.forEach((r) => {
          output.push(
            `
   ${getTestResultEmoji(r, this._recordingMetadatas)} ${r.metadata.title || "Unknown"}`
          );
          output.push(
            `      ${process.env.REPLAY_VIEW_HOST || "https://app.replay.io"}/recording/${r.id}`
          );
        });
      }
      if (crashed.length > 0) {
        output.push(
          `
\u2757\uFE0F ${crashed.length} crash reports were generated for tests that crashed while recording.
`
        );
        output.push(`  The Replay team has been notified.`);
      }
    }
    mixpanelClient.trackEvent("test-suite.results", {
      errors,
      numCrashed,
      numUploaded
    });
    if (output.length > 0) {
      logging.log(output.join("\n"));
    }
    return results;
  }
}

exports.ReporterError = ReporterError;
exports.default = ReplayReporter;

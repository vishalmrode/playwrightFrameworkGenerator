'use strict';

var undici = require('undici');
var createDeferred = require('./async/createDeferred.js');
var timeoutAfter = require('./async/timeoutAfter.js');

const cache = /* @__PURE__ */ new Map();
async function cachedFetch(url, init, options = {}) {
  const { baseDelay = 1e3, maxAttempts = 3, shouldRetry: shouldRetryFn } = options;
  const cached = cache.get(url);
  if (cached) {
    if (cached.entry) {
      return cached.entry;
    }
    return cached.deferred.promise;
  }
  const deferred = createDeferred.createDeferred();
  cache.set(url, { deferred, entry: void 0 });
  let attempt = 1;
  while (true) {
    let retryAfter = Math.pow(2, attempt) * baseDelay;
    try {
      const resp = await undici.fetch(url, init);
      const json = await resp.json().catch(() => null);
      if (resp.ok) {
        return storeCachedEntry(url, deferred, {
          json,
          ok: true,
          status: resp.status,
          statusText: resp.statusText
        });
      }
      let shouldRetry = attempt < maxAttempts;
      if (shouldRetry && shouldRetryFn) {
        const shouldRetryResult = await shouldRetryFn(resp, json, retryAfter);
        shouldRetry = !!shouldRetryResult;
        if (!shouldRetry) {
          return storeCachedEntry(url, deferred, {
            json,
            ok: false,
            status: resp.status,
            statusText: resp.statusText
          });
        }
        if (typeof shouldRetryResult === "object" && typeof shouldRetryResult.after === "number") {
          retryAfter = shouldRetryResult.after;
        }
      }
      if (!shouldRetry) {
        return storeCachedEntry(url, deferred, {
          json,
          ok: false,
          status: resp.status,
          statusText: resp.statusText
        });
      }
    } catch (error) {
      if (attempt === maxAttempts) {
        throw error;
      }
    }
    await timeoutAfter.timeoutAfter(retryAfter);
    attempt++;
  }
}
function storeCachedEntry(url, deferred, entry) {
  deferred.resolve(entry);
  cache.set(url, { deferred: void 0, entry });
  return entry;
}

exports.cache = cache;
exports.cachedFetch = cachedFetch;

'use strict';

var fsExtra = require('fs-extra');
var array = require('../array.js');
var logger = require('../logger.js');
var config = require('./config.js');
var types = require('./types.js');

const RECORDING_LOG_KINDS = [
  types.RECORDING_LOG_KIND.createRecording,
  types.RECORDING_LOG_KIND.addMetadata,
  types.RECORDING_LOG_KIND.writeStarted,
  types.RECORDING_LOG_KIND.sourcemapAdded,
  types.RECORDING_LOG_KIND.originalSourceAdded,
  types.RECORDING_LOG_KIND.writeFinished,
  types.RECORDING_LOG_KIND.uploadStarted,
  types.RECORDING_LOG_KIND.uploadFinished,
  types.RECORDING_LOG_KIND.uploadFailed,
  types.RECORDING_LOG_KIND.recordingUnusable,
  types.RECORDING_LOG_KIND.crashed,
  types.RECORDING_LOG_KIND.crashData,
  types.RECORDING_LOG_KIND.crashUploaded,
  types.RECORDING_LOG_KIND.processingStarted,
  types.RECORDING_LOG_KIND.processingFinished,
  types.RECORDING_LOG_KIND.processingFailed
];
function readRecordingLog() {
  const logEntries = [];
  const processLine = (line) => {
    line = line.trim();
    if (!line) {
      return;
    }
    const logEntry = JSON.parse(line);
    array.insert(
      logEntries,
      logEntry,
      (a, b) => RECORDING_LOG_KINDS.indexOf(a.kind) - RECORDING_LOG_KINDS.indexOf(b.kind)
    );
  };
  const rawText = fsExtra.readFileSync(config.recordingLogPath, "utf8");
  rawText.split(/[\n\r]+/).forEach((line) => {
    try {
      processLine(line);
    } catch {
      logger.logDebug("Error parsing line", { line });
      const splitLines = line.replace(/\}\{/g, "}\n{");
      if (splitLines.length === line.length) {
        return;
      }
      return splitLines.split(/[\n\r]+/).map((line2) => {
        try {
          processLine(line2);
        } catch (error) {
          logger.logDebug("Error parsing split line", { line: line2 });
        }
      });
    }
  });
  return logEntries;
}

exports.readRecordingLog = readRecordingLog;

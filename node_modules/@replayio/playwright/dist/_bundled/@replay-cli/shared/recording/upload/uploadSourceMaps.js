'use strict';

var fs = require('fs/promises');
var createPromiseQueue = require('../../async/createPromiseQueue.js');
var hashValue = require('../../hashValue.js');
var logger = require('../../logger.js');
var addOriginalSource = require('../../protocol/api/addOriginalSource.js');
var addSourceMap = require('../../protocol/api/addSourceMap.js');
var checkIfResourceExists = require('../../protocol/api/checkIfResourceExists.js');
var createResource = require('../../protocol/api/createResource.js');
var getResourceToken = require('../../protocol/api/getResourceToken.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);

async function ensureResource(client, content) {
  const { token } = await getResourceToken.getResourceToken(client, { hash: `sha256:${hashValue.hashValue(content)}` });
  const resource = {
    token,
    saltedHash: `sha256:${hashValue.hashValue(token + content)}`
  };
  const { exists } = await checkIfResourceExists.checkIfResourceExists(client, {
    resource
  });
  if (exists) {
    return resource;
  }
  return (await createResource.createResource(client, { content })).resource;
}
const queue = createPromiseQueue.createPromiseQueue({ concurrency: 10 });
async function uploadSourceMaps(client, recording) {
  const queueGroup = queue.fork();
  for (const sourceMap of recording.metadata.sourceMaps) {
    queueGroup.add(async () => {
      logger.logDebug(`Uploading source map ${sourceMap.path} for recording ${recording.id}`, {
        recording,
        sourceMap
      });
      let sourceMapId;
      try {
        const sourceMapContent = await fs__default.default.readFile(sourceMap.path, "utf-8");
        const result = await addSourceMap.addSourceMap(client, {
          recordingId: recording.id,
          baseURL: sourceMap.baseURL,
          targetContentHash: sourceMap.targetContentHash,
          targetURLHash: sourceMap.targetURLHash,
          targetMapURLHash: sourceMap.targetMapURLHash,
          resource: await ensureResource(client, sourceMapContent)
        });
        sourceMapId = result.id;
      } catch (error) {
        logger.logDebug(`Failed to upload source map ${sourceMap.path} for recording ${recording.id}`, {
          error,
          recording,
          sourceMap
        });
        return;
      }
      for (const source of sourceMap.originalSources) {
        queueGroup.add(async () => {
          logger.logDebug(
            `Uploading original source ${source.path} for source map ${sourceMap.path} for recording ${recording.id}`,
            { recording, source, sourceMap }
          );
          try {
            const sourceContent = await fs__default.default.readFile(source.path, "utf-8");
            await addOriginalSource.addOriginalSource(client, {
              recordingId: recording.id,
              parentId: sourceMapId,
              parentOffset: source.parentOffset,
              resource: await ensureResource(client, sourceContent)
            });
          } catch (error) {
            logger.logDebug(
              `Failed to upload original source ${source.path} for source map ${sourceMap.path} for recording ${recording.id}`,
              { error, recording, source, sourceMap }
            );
          }
        });
      }
    });
  }
  await queueGroup.waitUntilIdle();
}

exports.uploadSourceMaps = uploadSourceMaps;

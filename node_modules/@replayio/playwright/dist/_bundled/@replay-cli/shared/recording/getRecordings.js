'use strict';

var fsExtra = require('fs-extra');
var assert = require('node:assert/strict');
var path = require('path');
var logger = require('../logger.js');
var config = require('./config.js');
var readRecordingLog = require('./readRecordingLog.js');
var types = require('./types.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);

function getRecordings(processGroupIdFilter) {
  const recordings = [];
  const idToRecording = {};
  if (fsExtra.existsSync(config.recordingLogPath)) {
    const entries = readRecordingLog.readRecordingLog();
    logger.logDebug("Reading recording log", { entries, recordingLogPath: config.recordingLogPath });
    const idToStartTimestamp = {};
    for (let entry of entries) {
      switch (entry.kind) {
        case types.RECORDING_LOG_KIND.addMetadata: {
          const { id, metadata = {} } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          Object.assign(recording.metadata, metadata);
          const { argv, process, processGroupId, title, uri } = metadata;
          if (title) {
            recording.metadata.title = title;
          }
          if (uri) {
            let host = uri;
            if (host && typeof host === "string") {
              try {
                recording.metadata.host = new URL(host).host;
              } catch (error) {
                recording.metadata.host = host;
              }
            }
          } else if (Array.isArray(argv) && typeof argv[0] === "string") {
            recording.metadata.host = path.basename(argv[0]);
          }
          if (process) {
            recording.metadata.processType = process;
          }
          if (processGroupId) {
            recording.metadata.processGroupId = processGroupId;
          }
          break;
        }
        case types.RECORDING_LOG_KIND.crashData: {
          const { data, id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          if (recording.crashData) {
            recording.crashData.push(data);
          } else {
            recording.crashData = [data];
          }
          break;
        }
        case types.RECORDING_LOG_KIND.crashed: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.recordingStatus = "crashed";
          break;
        }
        case types.RECORDING_LOG_KIND.crashUploaded: {
          break;
        }
        case types.RECORDING_LOG_KIND.createRecording: {
          const recording = {
            buildId: entry.buildId,
            crashData: void 0,
            date: new Date(entry.timestamp),
            driverVersion: entry.driverVersion,
            duration: void 0,
            id: entry.id,
            metadata: {
              host: void 0,
              processGroupId: void 0,
              processType: void 0,
              sourceMaps: [],
              title: void 0,
              uri: void 0
            },
            path: void 0,
            processingStatus: void 0,
            recordingStatus: "recording",
            unusableReason: void 0,
            uploadStatus: void 0,
            uploadError: void 0
          };
          idToRecording[entry.id] = recording;
          recordings.push(recording);
          break;
        }
        case types.RECORDING_LOG_KIND.originalSourceAdded: {
          const { recordingId, parentId, path, parentOffset } = entry;
          assert__default.default(recordingId, '"originalSourceAdded" entry must have a "recordingId"');
          assert__default.default(parentId, '"originalSourceAdded" entry must have a "parentId"');
          assert__default.default(path, '"originalSourceAdded" entry must have a "path"');
          assert__default.default(
            typeof parentOffset === "number",
            '"originalSourceAdded" entry must have a numeric "parentOffset"'
          );
          const recording = idToRecording[recordingId];
          if (!recording) {
            logNotFoundWarning(recordingId, entry);
            continue;
          }
          const sourceMap = recording.metadata.sourceMaps.find(
            (sourceMap2) => sourceMap2.id === parentId
          );
          assert__default.default(sourceMap, `Source map with ID "${parentId}" not found`);
          sourceMap.originalSources.push({
            path,
            parentOffset
          });
          break;
        }
        case types.RECORDING_LOG_KIND.processingFailed: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.processingStatus = "failed";
          break;
        }
        case types.RECORDING_LOG_KIND.processingFinished: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.processingStatus = "processed";
          break;
        }
        case types.RECORDING_LOG_KIND.processingStarted: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.processingStatus = "processing";
          break;
        }
        case types.RECORDING_LOG_KIND.recordingUnusable: {
          const { id, reason } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.recordingStatus = "unusable";
          recording.unusableReason = reason;
          break;
        }
        case types.RECORDING_LOG_KIND.sourcemapAdded: {
          const {
            path,
            recordingId,
            id,
            baseURL,
            targetContentHash,
            targetURLHash,
            targetMapURLHash
          } = entry;
          assert__default.default(recordingId, '"sourcemapAdded" entry must have a "recordingId"');
          assert__default.default(path, '"sourcemapAdded" entry must have a "path"');
          assert__default.default(baseURL, '"sourcemapAdded" entry must have a "baseURL"');
          assert__default.default(targetMapURLHash, '"sourcemapAdded" entry must have a "targetMapURLHash"');
          const recording = idToRecording[recordingId];
          if (!recording) {
            logNotFoundWarning(recordingId, entry);
            continue;
          }
          recording.metadata.sourceMaps.push({
            id,
            path,
            baseURL,
            targetContentHash,
            targetURLHash,
            targetMapURLHash,
            originalSources: []
          });
          break;
        }
        case types.RECORDING_LOG_KIND.uploadFailed: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.uploadStatus = "failed";
          break;
        }
        case types.RECORDING_LOG_KIND.uploadFinished: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.uploadStatus = "uploaded";
          break;
        }
        case types.RECORDING_LOG_KIND.uploadStarted: {
          const { id } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.uploadStatus = "uploading";
          break;
        }
        case types.RECORDING_LOG_KIND.writeFinished: {
          const { id, timestamp } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.recordingStatus = "finished";
          const startTimestamp = idToStartTimestamp[id];
          if (startTimestamp != void 0) {
            recording.duration = timestamp - idToStartTimestamp[id];
          }
          break;
        }
        case types.RECORDING_LOG_KIND.writeStarted: {
          const { id, path, timestamp } = entry;
          const recording = idToRecording[id];
          if (!recording) {
            logNotFoundWarning(id, entry);
            continue;
          }
          recording.path = path;
          idToStartTimestamp[id] = timestamp;
          break;
        }
      }
    }
  }
  logger.logDebug(`Found ${recordings.length} recordings`, { recordings });
  return recordings.filter((recording) => {
    switch (recording.recordingStatus) {
      case "finished":
        if (!recording.metadata.host) {
          return false;
        }
        break;
    }
    return true;
  }).sort((a, b) => b.date.getTime() - a.date.getTime());
}
function logNotFoundWarning(recordingId, entry) {
  logger.logError("RecordingLog:RecordingNotFound", {
    recordingId,
    entry
  });
}

exports.getRecordings = getRecordings;

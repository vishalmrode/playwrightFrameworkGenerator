'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var assert = require('node:assert/strict');
var WebSocket = require('ws');
var createDeferred = require('../async/createDeferred.js');
var config = require('../config.js');
var logger = require('../logger.js');
var ProtocolError = require('./ProtocolError.js');
var setAccessToken = require('./api/setAccessToken.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var assert__default = /*#__PURE__*/_interopDefault(assert);
var WebSocket__default = /*#__PURE__*/_interopDefault(WebSocket);

class ProtocolClient {
  deferredAuthenticated = createDeferred.createDeferred();
  eventListeners = /* @__PURE__ */ new Map();
  nextMessageId = 1;
  pendingCommands = /* @__PURE__ */ new Map();
  socket;
  accessToken;
  constructor(accessToken) {
    logger.logDebug(`Creating WebSocket for ${config.replayWsServer}`);
    this.accessToken = accessToken;
    this.socket = new WebSocket__default.default(config.replayWsServer);
    this.socket.on("close", this.onSocketClose);
    this.socket.on("error", this.onSocketError);
    this.socket.on("open", this.onSocketOpen);
    this.socket.on("message", this.onSocketMessage);
    this.listenForMessage("Recording.sessionError", (error) => {
      if (error.sessionId) {
        this.pendingCommands.forEach((deferred) => {
          if (deferred.status === createDeferred.STATUS_PENDING && deferred.data?.sessionId === error.sessionId) {
            deferred.reject(
              new ProtocolError.ProtocolError({
                code: error.code,
                message: error.message,
                data: {
                  sessionId: error.sessionId
                }
              })
            );
          }
        });
      }
    });
  }
  close() {
    this.socket.close();
  }
  listenForMessage(method, callback) {
    let listeners = this.eventListeners.get(method);
    if (listeners == null) {
      listeners = /* @__PURE__ */ new Set([callback]);
      this.eventListeners.set(method, listeners);
    } else {
      listeners.add(callback);
    }
    return () => {
      listeners.delete(callback);
    };
  }
  sendCommand({
    method,
    params,
    sessionId
  }) {
    const id = this.nextMessageId++;
    logger.logDebug("Sending command", { id, method, params, sessionId });
    const command = {
      id,
      method,
      params,
      sessionId
    };
    this.socket.send(JSON.stringify(command), (error) => {
      if (error) {
        logger.logDebug("Received socket error", { error });
      }
    });
    const deferred = createDeferred.createDeferred({ sessionId, command });
    this.pendingCommands.set(id, deferred);
    return deferred.promise;
  }
  waitUntilAuthenticated() {
    return this.deferredAuthenticated.promise;
  }
  onSocketClose = () => {
    if (this.deferredAuthenticated.status === createDeferred.STATUS_PENDING) {
      this.deferredAuthenticated.reject(new Error("Socket closed before authentication completed"));
    }
  };
  onSocketError = (error) => {
    logger.logError("ProtocolClient:Error", { error });
    if (this.deferredAuthenticated.status === createDeferred.STATUS_PENDING) {
      this.deferredAuthenticated.reject(error);
    }
  };
  onSocketMessage = (contents) => {
    const { error, id, method, params, result } = JSON.parse(String(contents));
    if (id) {
      const deferred = this.pendingCommands.get(id);
      assert__default.default(deferred, `Received message with unknown id: ${id}`);
      this.pendingCommands.delete(id);
      if (result) {
        logger.logDebug("Resolving response", { contents });
        deferred.resolve(result);
      } else if (error) {
        logger.logDebug("Received error", { contents });
        deferred.reject(new ProtocolError.ProtocolError(error));
      } else {
        logger.logDebug("Received error", { contents });
        deferred.reject(new Error(`Channel error: ${contents}`));
      }
    } else if (this.eventListeners.has(method)) {
      logger.logDebug("Received event", { contents });
      const callbacks = this.eventListeners.get(method);
      if (callbacks) {
        callbacks.forEach((callback) => callback(params));
      }
    } else {
      logger.logDebug("Received message without a handler", { contents });
    }
  };
  onSocketOpen = async () => {
    try {
      await setAccessToken.setAccessToken(this, { accessToken: this.accessToken });
      this.deferredAuthenticated.resolve(true);
    } catch (error) {
      logger.logError("ProtocolClient:ServerAuthFailed", { error });
      this.socket.close();
      this.deferredAuthenticated.reject(error);
    }
  };
}

exports.default = ProtocolClient;

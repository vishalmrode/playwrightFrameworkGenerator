'use strict';

var createDeferred = require('../async/createDeferred.js');
var isPromiseLike = require('../async/isPromiseLike.js');
var timeoutAfter = require('../async/timeoutAfter.js');
var waitForAuthInfo = require('./waitForAuthInfo.js');
var waitForPackageInfo = require('./waitForPackageInfo.js');

const FLUSH_TIMEOUT = 500;
function createTaskQueue({
  onDestroy,
  onInitialize
}) {
  let cachedAuthInfo;
  let cachedPackageInfo;
  let destroyed = false;
  let initialized = false;
  let queue = /* @__PURE__ */ new Set();
  waitForPackageInfo.waitForPackageInfo().then((packageInfo) => {
    cachedPackageInfo = packageInfo;
    if (cachedAuthInfo !== void 0) {
      initialized = true;
      onInitialize({
        authInfo: cachedAuthInfo,
        packageInfo: cachedPackageInfo
      });
      flush();
    }
  });
  waitForAuthInfo.waitForAuthInfo().then((authInfo) => {
    cachedAuthInfo = authInfo ?? null;
    if (cachedPackageInfo !== void 0) {
      initialized = true;
      onInitialize({
        authInfo: cachedAuthInfo,
        packageInfo: cachedPackageInfo
      });
      flush();
    }
  });
  async function flush() {
    if (!initialized) {
      if (cachedPackageInfo === void 0) {
        return;
      }
      initialized = true;
      onInitialize({
        authInfo: cachedAuthInfo || null,
        packageInfo: cachedPackageInfo
      });
    }
    const clonedQueue = Array.from(queue);
    const promises = clonedQueue.map((queued) => {
      if (queued.status === "waiting") {
        runTask(queued);
      }
      return queued.deferred.promise;
    });
    await Promise.race([timeoutAfter.timeoutAfter(FLUSH_TIMEOUT, false), Promise.all(promises)]);
  }
  async function flushAndClose() {
    if (destroyed) {
      return;
    }
    destroyed = true;
    if (queue.size > 0) {
      await flush();
    }
    await onDestroy();
  }
  function push(task) {
    const queued = {
      deferred: createDeferred.createDeferred(),
      status: "waiting",
      task
    };
    queue.add(queued);
    if (initialized) {
      runTask(queued);
    }
  }
  async function runTask(queued) {
    const { deferred, task } = queued;
    try {
      queued.status = "running";
      const maybePromise = task(cachedAuthInfo || void 0);
      if (isPromiseLike.isPromiseLike(maybePromise)) {
        await maybePromise;
      }
    } catch {
    } finally {
      deferred.resolve();
      queued.status = "finished";
      queue.delete(queued);
    }
  }
  return {
    flushAndClose,
    push,
    get queueSize() {
      return queue.size;
    }
  };
}

exports.createTaskQueue = createTaskQueue;

'use strict';

var crypto = require('crypto');
var dbg = require('debug');
var StackUtils = require('stack-utils');
var winston = require('winston');
var LokiTransport = require('winston-loki');
var getDeviceId = require('./getDeviceId.js');
var createTaskQueue = require('./session/createTaskQueue.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var dbg__default = /*#__PURE__*/_interopDefault(dbg);
var StackUtils__default = /*#__PURE__*/_interopDefault(StackUtils);
var winston__default = /*#__PURE__*/_interopDefault(winston);
var LokiTransport__default = /*#__PURE__*/_interopDefault(LokiTransport);

const GRAFANA_USER = "909360";
const GRAFANA_PUBLIC_TOKEN = "glc_eyJvIjoiOTEyOTQzIiwibiI6IndyaXRlLW90ZWwtcmVwbGF5LWNsaSIsImsiOiJ0UnFsOXV1a2QyQUI2NzIybDEzSkRuNDkiLCJtIjp7InIiOiJwcm9kLXVzLWVhc3QtMCJ9fQ==";
const GRAFANA_BASIC_AUTH = `${GRAFANA_USER}:${GRAFANA_PUBLIC_TOKEN}`;
const HOST = "https://logs-prod-006.grafana.net";
const stackUtils = new StackUtils__default.default({ cwd: process.cwd(), internals: StackUtils__default.default.nodeInternals() });
const deviceId = getDeviceId.getDeviceId();
const localDebugger = dbg__default.default("replay");
const sessionId = crypto.randomUUID();
let grafana = null;
const taskQueue = createTaskQueue.createTaskQueue({
  onDestroy: async () => {
    if (process.env.REPLAY_TELEMETRY_DISABLED) {
      return;
    }
    if (grafana) {
      await grafana.close();
    }
  },
  onInitialize: ({ packageInfo: { packageName, packageVersion } }) => {
    const lokiTransport = new LokiTransport__default.default({
      basicAuth: GRAFANA_BASIC_AUTH,
      format: winston__default.default.format.json(),
      gracefulShutdown: true,
      host: HOST,
      json: true,
      labels: { app: packageName, version: packageVersion },
      onConnectionError: (err) => localDebugger("Grafana connection error", err),
      replaceTimestamp: true,
      timeout: 5e3
    });
    grafana = {
      close: async () => {
        await lokiTransport.flush().catch(() => {
        });
        lokiTransport.close?.();
      },
      logger: winston__default.default.createLogger({
        // Levels greater than or equal to "info" ("info", "warn", "error") will be logged.
        // See https://github.com/winstonjs/winston?tab=readme-ov-file#logging.
        level: "info",
        transports: [lokiTransport]
      })
    };
  }
});
async function flushLog() {
  await taskQueue.flushAndClose();
}
function logDebug(message, tags) {
  log(message, "debug", tags);
}
function logError(message, tags) {
  log(message, "error", tags);
}
function logInfo(message, tags) {
  log(message, "info", tags);
}
function anonymizeStackTrace(stack) {
  return stack.split("\n").map((line) => {
    const frame = stackUtils.parseLine(line);
    if (frame && frame.file) {
      const relativePath = frame.file.includes("node_modules") ? frame.file.substring(frame.file.indexOf("node_modules")) : frame.file;
      return line.replace(frame.file, relativePath);
    }
    return line;
  }).join("\n");
}
function log(message, level, tags) {
  taskQueue.push((authInfo) => {
    const formattedTags = formatTags(tags);
    localDebugger(message, formattedTags);
    if (process.env.REPLAY_TELEMETRY_DISABLED) {
      return;
    }
    const entry = {
      level,
      message,
      ...formattedTags,
      deviceId,
      sessionId
    };
    if (authInfo) {
      switch (authInfo.type) {
        case "user": {
          entry.userId = authInfo.id;
          break;
        }
        case "workspace": {
          entry.workspaceId = authInfo.id;
          break;
        }
      }
    }
    if (grafana) {
      grafana.logger.log(entry);
    }
  });
}
function formatTags(tags) {
  if (!tags) {
    return;
  }
  return Object.entries(tags).reduce((result, [key, value]) => {
    if (value instanceof Error) {
      result[key] = {
        // Intentionally keeping this for any extra properties attached in `Error`
        ...value,
        errorName: value.name,
        errorMessage: value.message,
        errorStack: anonymizeStackTrace(value.stack ?? "")
      };
    } else {
      result[key] = value;
    }
    return result;
  }, {});
}

exports.flushLog = flushLog;
exports.logDebug = logDebug;
exports.logError = logError;
exports.logInfo = logInfo;
